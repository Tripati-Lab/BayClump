# Define server logic
server <- function(input, output, session) { 
  options(shiny.maxRequestSize=800*1024^2) 
  
  # Show package citations
  get_path <- reactive({
    path <- file.path(paste0(getwd()), paste("Rpackages", ".bib", sep=""))
    return(path)
  })
  
  get_bib <- reactive({
    ## insert your get bib logic here
    pkgbib <- bibtex::read.bib("Rpackages.bib")
    
    df <- bib2df(get_path()) %>% dplyr::select(BIBTEXKEY, NOTE, AUTHOR, TITLE, YEAR, JOURNAL, VOLUME, PAGES, URL)
    df$AUTHOR <- unlist(lapply(df$AUTHOR, paste, collapse = ", "))
    df <- df %>% arrange(AUTHOR)
    return(df)
  })
  
  output$bibTable <- DT::renderDataTable({
    
    bib <- get_bib()
    bib
    
  }, caption = "This is an automatically generated list of R packages used to render and run BayClump. Citation information is provided by package authors.", options = list(pageLength = 20, info = FALSE))
  
  # Calibration tab
  
  output$BayClump_cal_temp <- downloadHandler(
    filename = "BayClump_calibration_template.csv",
    content = function(file) {
      write.csv(BayClump_calibration_template, file, row.names = FALSE)
    }
  )
  
  
  
  calibrationData = reactive({
    switch(input$calset,
           "model1" = return(Petersen),
           "model2" = return(Anderson),
           "model1and2" = return(PetersenAnderson),
           "mycal" = reactiveValues({
             req(input$calibrationdata)
             n_rows = length(count.fields(input$calibrationdata$datapath))
             df_out = read.csv(input$calibrationdata$datapath)
             return(df_out)
           }),
           "all" = reactiveValues({
             req(input$calibrationdata)
             n_rows = length(count.fields(input$calibrationdata$datapath))
             df_out = read.csv(input$calibrationdata$datapath)
             alldat <- rbind(df_out, PetersenAnderson)
             return(alldat)
           })
    )
  })

  #For parameter estimates
  if(exists("wb")) rm(wb) # Delete any existing workbook in preparation for new results
  wb <- createWorkbook("calibration output") # Prepare a workbook for calibration outputs
  
  #For convergence
  if(exists("wb3")) rm(wb3) # Delete any existing workbook in preparation for new results
  wb3 <- createWorkbook("Bayesian output") # Prepare a workbook for calibration outputs
  
  
  if(exists("wb4")) rm(wb4) # Delete any existing workbook in preparation for new results
  wb4 <- createWorkbook("Bayesian posterior output") # Prepare a workbook for calibration outputs
  
  #For convergence
  if(exists("wb5")) rm(wb5) # Delete any existing workbook in preparation for new results
  wb5 <- createWorkbook("Bayesian reconstruction posterior output") # Prepare a workbook for calibration outputs
  
  
  observeEvent(calibrationData(),{
  output$myList <-  renderUI({
    numericInput("samples", min = 3, max = nrow(calibrationData()), 
                label = paste0("Number of observations per bootstrap sample, (max. recommended: ", nrow(calibrationData()) ,")" ), 
                value =  nrow(calibrationData()))
  })
  })
  
  
  
  observe({
    output$contents <- renderTable({
      calsummary <- calibrationData() %>%
        summarize(
          "Total samples" = length(calibrationData()$Sample.Name),
          "Unique samples" = length(unique(calibrationData()$Sample.Name)),
          "Total replicates" = sum(calibrationData()$N),
          "Materials" = length(unique(calibrationData()$Material))
        )
      return(calsummary)
    }, 
    rownames=FALSE, options = list(pageLength = 1, info = FALSE)
    )
  }) 
  

  toListen <- reactive({
    list(input$runmods,
         input$priors, 
         input$multicore
         )
  })
  
  modresult <- eventReactive(toListen() , {
    
    if ("all" %in% input$calibrationdata) {
      print(noquote("Please upload calibration data first"))
    } 
    
    hasMaterial <<- ifelse( is.na(calibrationData()$Material), FALSE, TRUE )
    
    priors <<- input$priors
    replicates <<- input$replication
    ngenerationsBayes <<- input$generations
    ngenerationsBayesianPredictions <<- input$generations

    ##Download priors (calibration; not reactive...)
    if(exists("wb6")) rm(wb6)
    wb6 <- createWorkbook("Priors - Calibration")
    if("Settings" %in% names(wb6) == TRUE) 
    {removeWorksheet(wb6, "Settings")}
    if("Distributions" %in% names(wb6) == TRUE) 
    {removeWorksheet(wb6, "Distributions") }
    pd <- generatePriorDistCalibration(prior = priors)
    addWorksheet(wb6, "Settings") # Add a blank sheet
    writeData(wb6, sheet = "Settings", attr(pd, "params")) # Write regression data
    addWorksheet(wb6, "Distributions") # Add a blank sheet
    writeData(wb6, sheet = "Distributions", pd) # Write regression data
    
    output$downloadPriorsCalibration <- downloadHandler(
      filename = function() { 
        paste("Priors_calibration_", Sys.time(), ".xlsx", sep="")
      },
      content = function(file) {
        saveWorkbook(wb6, file, overwrite = TRUE)
      }
    )
    
    ##Download priors (reconstructions)
    if(exists("wb7")) rm(wb7)
    wb7 <- createWorkbook("Priors - Reconstruction")
    if("Settings" %in% names(wb7) == TRUE) 
    {removeWorksheet(wb7, "Settings")}
    if("Distributions" %in% names(wb7) == TRUE) 
    {removeWorksheet(wb7, "Distributions") }
    pd <- generatePriorReconstructions(prior = priors)
    addWorksheet(wb7, "Settings") # Add a blank sheet
    writeData(wb7, sheet = "Settings", attr(pd, "params")) # Write regression data
    addWorksheet(wb7, "Distributions") # Add a blank sheet
    writeData(wb7, sheet = "Distributions", pd) # Write regression data
    
    output$downloadPriorsReconstruction <- downloadHandler(
      filename = function() { 
        paste("Priors_reconstruction_", Sys.time(), ".xlsx", sep="")
      },
      content = function(file) {
        saveWorkbook(wb7, file, overwrite = TRUE)
      }
    )
    
    
    
    
    # Remove existing worksheets from wb on "run" click, if any
    if("Linear regression" %in% names(wb) == TRUE) 
    {removeWorksheet(wb, "Linear regression") & removeWorksheet(wb, "Linear regression CI")}
    if("Inverse linear regression" %in% names(wb) == TRUE) 
    {removeWorksheet(wb, "Inverse linear regression") & removeWorksheet(wb, "Inverse linear regression CI")}
    if("York regression" %in% names(wb) == TRUE) 
    {removeWorksheet(wb, "York regression") & removeWorksheet(wb, "York regression CI")}
    if("Deming regression" %in% names(wb) == TRUE) 
    {removeWorksheet(wb, "Deming regression") & removeWorksheet(wb, "Deming regression CI")}
    if("Bayesian model no errors" %in% names(wb) == TRUE) 
    {removeWorksheet(wb, "Bayesian model no errors") & removeWorksheet(wb, "Bayesian model no errors CI")}
    if("Bayesian model with errors" %in% names(wb) == TRUE) 
    {removeWorksheet(wb, "Bayesian model with errors") & removeWorksheet(wb, "Bayesian model with errors CI")}
    if("Bayesian mixed w errors" %in% names(wb) == TRUE)
    {removeWorksheet(wb, "Bayesian mixed w errors") & removeWorksheet(wb, "Bayesian mixed w errors CI")}
    
    
    ##Also for the Bayesian sheet
    if("Bayesian model no errors" %in% names(wb3) == TRUE) 
    {removeWorksheet(wb3, "Bayesian model no errors")}
    if("Bayesian model with errors" %in% names(wb3) == TRUE) 
    {removeWorksheet(wb3, "Bayesian model with errors") }
    if("Bayesian mixed w errors" %in% names(wb3) == TRUE)
    {removeWorksheet(wb3, "Bayesian mixed w errors")}
    
    ##Also for the Bayesian posterior sheet
    if("Bayesian model no errors" %in% names(wb4) == TRUE) 
    {removeWorksheet(wb4, "Bayesian model no errors")}
    if("Bayesian model with errors" %in% names(wb4) == TRUE) 
    {removeWorksheet(wb4, "Bayesian model with errors") }
    if("Bayesian mixed w errors" %in% names(wb4) == TRUE)
    {removeWorksheet(wb4, "Bayesian mixed w errors")}
    

    
    lmcals <<- NULL
    lminversecals <<- NULL
    yorkcals <<- NULL
    demingcals <<- NULL
    bayeslincals <<- NULL
    bayesmixedcals <<- NULL
    
    
    calData <<- NULL
    calData <<- calibrationData()

    samples <<- if(is.null(input$samples)){nrow(calData) }else{input$samples}
    samples <<- ifelse(samples==2, 3, samples)
    multicore <<- input$simulateDeming
      
    # Recode NA or 0 error values to dummy value
    calData$D47error[calData$D47error == 0] <<- 0.000001
    calData$TempError[calData$TempError == 0] <<- 0.000001
    calData$D47error[is.na(calData$D47error)] <<- 0.000001
    calData$TempError[is.na(calData$TempError)] <<- 0.000001
    calData$Material[is.na(calData$Material)] <<- 1
    
    
    ##Limits of the CI
    
    minLim <- ifelse(input$range[1]==0, min(calData$Temperature),input$range[1])
    maxLim <- ifelse(input$range[2]==0, max(calData$Temperature),input$range[2])
    

    
    if(input$scale == TRUE) {
      calData$Temperature <<- scale(calData$Temperature)
      calData$TempError <<- scale(calData$TempError)
      calData$D47 <<- scale(calData$D47)
      calData$D47error <<- scale(calData$D47error)
    }
    

    
    if(input$simulateLM_measured == FALSE &
       input$simulateLM_inverseweights == FALSE &
       input$simulateYork_measured == FALSE &
       input$simulateDeming == FALSE &
       input$simulateBLM_measuredMaterial == FALSE &
       input$simulateBLMM_measuredMaterial == FALSE) {print(noquote("Please select at least one model"))}
    
    if(input$simulateLM_measured != FALSE |
       input$simulateLM_inverseweights != FALSE |
       input$simulateYork_measured != FALSE |
       input$simulateDeming != FALSE |
       input$simulateBLM_measuredMaterial != FALSE |
       input$simulateBLMM_measuredMaterial != FALSE) {
      
      withProgress(message = "Running selected models, please wait", {
        
        if(input$simulateLM_measured == FALSE) {
        }
        if(input$simulateLM_inverseweights == FALSE) {
        }
        if(input$simulateYork_measured == FALSE) {
        }
        if(input$simulateDeming == FALSE) {
        }
        if(input$simulateBLM_measuredMaterial == FALSE) {
        }
        if(input$simulateBLMM_measuredMaterial == FALSE) {
        }
        
        totalModels <- c(input$simulateLM_measured, input$simulateLM_inverseweights, input$simulateYork_measured,
                         input$simulateDeming, input$simulateBLM_measuredMaterial, input$simulateBLMM_measuredMaterial)
        TotProgress <- length(which(totalModels==T))
        
        if(input$simulateLM_measured != FALSE) {
          sink(file = "out/linmodtext.txt", type = "output")
          lmcals <<- simulateLM_measured(calData, replicates = replicates, samples = samples)
          sink()
          incProgress(1/TotProgress, detail="...Done fitting the OLS...")
          
          lmci <<- RegressionSingleCI(data = lmcals, from = minLim, to = maxLim)
          lmcalci <- as.data.frame(lmci)
          
          output$lmcalibration <- renderPlotly({
            lmfig <- plot_ly(calibrationData()
            )
            lmfig <- lmfig %>%
              add_trace(x = ~calibrationData()$Temperature, 
                        y = ~D47,
                        type = "scatter", 
                        mode = "markers", 
                        marker = list(color = "black"),
                        opacity = 0.5,
                        name = "Raw data",
                        text = as.character(calibrationData()$Sample.Name),
                        hovertemplate = paste(
                          "<b>Sample: %{text}</b><br><br>",
                          "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                          "Δ<sub>47</sub> (‰): %{y}<br>",
                          "Mineralogy: ", as.character(calibrationData()$Mineralogy),"<br>",
                          "Type: ", as.character(calibrationData()$Material),
                          "<extra></extra>"))
            lmfig <- lmfig %>% 
              add_ribbons(data = lmcalci,
                          x = ~x,
                          y = ~mean_est,
                          ymin = ~ci_lower_est,
                          ymax = ~ci_upper_est,
                          line = list(color = "#ffd166"),
                          fillcolor = "#ffd166",
                          opacity = 0.5,
                          name = "95% CI",
                          hovertemplate = paste(
                            "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                            "Δ<sub>47</sub> (‰): %{y}<br>")) %>%
              add_lines(data = lmcalci,
                        x = ~x,
                        y = ~mean_est,
                        name = "Mean estimate",
                        line = list(color = "black", dash = "dash"),
                        hovertemplate = paste(
                          "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                          "Δ<sub>47</sub> (‰): %{y}<br>"))
            lmfig <- lmfig %>% layout(title = "<b> Linear calibration model </b>",
                                      legend=list(title=list(text="Legend")),
                                      xaxis = list(title = "Temperature (10<sup>6</sup>/T<sup>2</sup>)", hoverformat = ".1f"), 
                                      yaxis = list(title = "Δ<sub>47</sub> (‰)", hoverformat = ".3f"))
            
            return(lmfig)
          })
          
          addWorksheet(wb, "Linear regression") # Add a blank sheet
          addWorksheet(wb, "Linear regression CI") # Add a blank sheet 
          
          lmcalci2 <- lmcalci
          names(lmcalci2) <- c("10^6/T^2", "D47_mean_est",	"D47_ci_lower_est",	"D47_ci_upper_est")
          
          writeData(wb, sheet = "Linear regression", lmcals) # Write regression data
          writeData(wb, sheet = "Linear regression CI", lmcalci2)
          
          
          
          cat("Linear regression complete \n *R^2=", round(unlist(attributes(lmcals)$R2[1],4)),
              " (95% CI, ",round(unlist(attributes(lmcals)$R2[2],4)),"-",round(unlist(attributes(lmcals)$R2[3],4)),")"
          )
          

          output$lmcal <- renderPrint({
            do.call(rbind.data.frame,apply(lmcals, 2, function(x){
              cbind.data.frame(Mean= round(mean(x), 4), `SE`=round(sd(x)/sqrt(length(x)),7))
            }))
          })
          
        }
        
        if(input$simulateLM_inverseweights != FALSE) {
          sink(file = "out/inverselinmodtext.txt", type = "output")
          lminversecals <<- simulateLM_inverseweights(calData, replicates = replicates, samples = samples)
          sink()
          incProgress(1/TotProgress, detail="...Done fitting weighted OLS...")
          
          lminverseci <- RegressionSingleCI(data = lminversecals, from = minLim, to = maxLim)
          lminversecalci <- as.data.frame(lminverseci)
          
          output$lminversecalibration <- renderPlotly({
            lminversefig <- plot_ly(data = calibrationData()
            )
            lminversefig <- lminversefig %>% 
              add_trace(x = ~calibrationData()$Temperature, 
                        y = ~D47,
                        type = "scatter", 
                        mode = "markers", 
                        marker = list(color = "black"),
                        opacity = 0.5,
                        name = "Raw data",
                        text = as.character(calibrationData()$Sample.Name),
                        hovertemplate = paste(
                          "<b>Sample: %{text}</b><br><br>",
                          "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                          "Δ<sub>47</sub> (‰): %{y}<br>",
                          "Mineralogy: ", as.character(calibrationData()$Mineralogy),"<br>",
                          "Type: ", as.character(calibrationData()$Material),
                          "<extra></extra>")) %>%
              add_ribbons(data = lminversecalci,
                          x = ~x,
                          y = ~mean_est,
                          ymin = ~ci_lower_est,
                          ymax = ~ci_upper_est,
                          line = list(color = "#ffd166"),
                          fillcolor = "#ffd166",
                          opacity = 0.5,
                          name = "95% CI",
                          hovertemplate = paste(
                            "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                            "Δ<sub>47</sub> (‰): %{y}<br>")) %>%
              add_lines(data = lminversecalci,
                        x = ~x,
                        y = ~mean_est,
                        name = "Mean estimate",
                        line = list(color = "black", dash = "dash"),
                        hovertemplate = paste(
                          "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                          "Δ<sub>47</sub> (‰): %{y}<br>"))
            lminversefig <- lminversefig %>% layout(title = "<b> Inverse linear calibration model </b>",
                                                    legend=list(title=list(text="Legend")),
                                                    xaxis = list(title = "Temperature (10<sup>6</sup>/T<sup>2</sup>)", hoverformat = ".1f"), 
                                                    yaxis = list(title = "Δ<sub>47</sub> (‰)", hoverformat = ".3f"))
            
            return(lminversefig)
          })
          
          addWorksheet(wb, "Inverse linear regression") # Add a blank sheet
          addWorksheet(wb, "Inverse linear regression CI") # Add a blank sheet 
          
          lminversecalci2 <- lminversecalci
          names(lminversecalci2) <- c("10^6/T^2", "D47_mean_est",	"D47_ci_lower_est",	"D47_ci_upper_est")
          
          writeData(wb, sheet = "Inverse linear regression", lminversecals) # Write regression data
          writeData(wb, sheet = "Inverse linear regression CI", lminversecalci2)
          
          cat("\nInverse regression complete \n *R^2=", round(unlist(attributes(lminversecals)$R2[1],4)),
              " (95% CI, ",round(unlist(attributes(lminversecals)$R2[2],4)),"-",round(unlist(attributes(lminversecals)$R2[3],4)),")"
          )
          
          output$lminversecal <- renderPrint({
            do.call(rbind.data.frame,apply(lminversecals, 2, function(x){
              cbind.data.frame(Mean= round(mean(x), 4),`SE`=round(sd(x)/sqrt(length(x)),7))
            }))
          })
          
        }
        
        if(input$simulateYork_measured != FALSE) {
          sink(file = "out/yorkmodtext.txt", type = "output")
          yorkcals <<- simulateYork_measured(calData, replicates = replicates, samples = samples)
          sink()
          incProgress(1/TotProgress, detail="...Done fitting York regression...")
          
          yorkci <- RegressionSingleCI(data = yorkcals, from = minLim, to = maxLim)
          yorkcalci <- as.data.frame(yorkci)
          
          output$yorkcalibration <- renderPlotly({
            yorkfig <- plot_ly(data = calibrationData()
            )
            yorkfig <- yorkfig %>% 
              add_trace(x = ~calibrationData()$Temperature, 
                        y = ~D47,
                        type = "scatter", 
                        mode = "markers", 
                        marker = list(color = "black"),
                        opacity = 0.5,
                        name = "Raw data",
                        text = as.character(calibrationData()$Sample.Name),
                        hovertemplate = paste(
                          "<b>Sample: %{text}</b><br><br>",
                          "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                          "Δ<sub>47</sub> (‰): %{y}<br>",
                          "Mineralogy: ", as.character(calibrationData()$Mineralogy),"<br>",
                          "Type: ", as.character(calibrationData()$Material),
                          "<extra></extra>")) %>%
              add_ribbons(data = yorkcalci,
                          x = ~x,
                          y = ~mean_est,
                          ymin = ~ci_lower_est,
                          ymax = ~ci_upper_est,
                          line = list(color = "#ffd166"),
                          fillcolor = "#ffd166",
                          opacity = 0.5,
                          name = "95% CI",
                          hovertemplate = paste(
                            "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                            "Δ<sub>47</sub> (‰): %{y}<br>")) %>%
              add_lines(data = yorkcalci,
                        x = ~x,
                        y = ~mean_est,
                        name = "Mean estimate",
                        line = list(color = "black", dash = "dash"),
                        hovertemplate = paste(
                          "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                          "Δ<sub>47</sub> (‰): %{y}<br>"))
            yorkfig <- yorkfig %>% layout(title = "<b> York calibration model </b>",
                                          legend=list(title=list(text="Legend")),
                                          xaxis = list(title = "Temperature (10<sup>6</sup>/T<sup>2</sup>)", hoverformat = ".1f"), 
                                          yaxis = list(title = "Δ<sub>47</sub> (‰)", hoverformat = ".3f"))
            
            return(yorkfig)
          })
          
          addWorksheet(wb, "York regression") # Add a blank sheet
          addWorksheet(wb, "York regression CI") # Add a blank sheet 
          
          yorkcalci2 <- yorkcalci
          names(yorkcalci2) <- c("10^6/T^2", "D47_mean_est",	"D47_ci_lower_est",	"D47_ci_upper_est")
          
          writeData(wb, sheet = "York regression", yorkcals) # Write regression data
          writeData(wb, sheet = "York regression CI", yorkcalci2)
          
          cat("\nYork regression complete")
          output$york <- renderPrint({
            do.call(rbind.data.frame,apply(yorkcals, 2, function(x){
              cbind.data.frame(Mean= round(mean(x), 4),`SE`=round(sd(x)/sqrt(length(x)),7))
            }))
          })
          
        }
        
        if(input$simulateDeming != FALSE) {
          sink(file = "out/demingmodtext.txt", type = "output")
          demingcals <<- simulateDeming(calData, replicates = replicates, samples = samples, multicore=multicore)
          sink()
          incProgress(1/TotProgress, detail="...Done fitting Deming regression model...")
          
          demingci <- RegressionSingleCI(data = demingcals, from = minLim, to = maxLim)
          demingcalci <- as.data.frame(demingci)
          
          output$demingcalibration <- renderPlotly({
            demingfig <- plot_ly(data = calibrationData()
            )
            demingfig <- demingfig %>% 
              add_trace(x = ~calibrationData()$Temperature, 
                        y = ~D47,
                        type = "scatter", 
                        mode = "markers", 
                        marker = list(color = "black"),
                        opacity = 0.5,
                        name = "Raw data",
                        text = as.character(calibrationData()$Sample.Name),
                        hovertemplate = paste(
                          "<b>Sample: %{text}</b><br><br>",
                          "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                          "Δ<sub>47</sub> (‰): %{y}<br>",
                          "Mineralogy: ", as.character(calibrationData()$Mineralogy),"<br>",
                          "Type: ", as.character(calibrationData()$Material),
                          "<extra></extra>")) %>%
              add_ribbons(data = demingcalci,
                          x = ~x,
                          y = ~mean_est,
                          ymin = ~ci_lower_est,
                          ymax = ~ci_upper_est,
                          line = list(color = "#ffd166"),
                          fillcolor = "#ffd166",
                          opacity = 0.5,
                          name = "95% CI",
                          hovertemplate = paste(
                            "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                            "Δ<sub>47</sub> (‰): %{y}<br>")) %>%
              add_lines(data = demingcalci,
                        x = ~x,
                        y = ~mean_est,
                        name = "Mean estimate",
                        line = list(color = "black", dash = "dash"),
                        hovertemplate = paste(
                          "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                          "Δ<sub>47</sub> (‰): %{y}<br>"))
            demingfig <- demingfig %>% layout(title = "<b> Deming calibration model </b>",
                                              legend=list(title=list(text="Legend")),
                                              xaxis = list(title = "Temperature (10<sup>6</sup>/T<sup>2</sup>)", hoverformat = ".1f"), 
                                              yaxis = list(title = "Δ<sub>47</sub> (‰)", hoverformat = ".3f"))
            
            return(demingfig)
          })
          
          addWorksheet(wb, "Deming regression") # Add a blank sheet
          addWorksheet(wb, "Deming regression CI") # Add a blank sheet 
          
          demingcalci2 <- demingcalci
          names(demingcalci2) <- c("10^6/T^2", "D47_mean_est",	"D47_ci_lower_est",	"D47_ci_upper_est")
          
          writeData(wb, sheet = "Deming regression", demingcals) # Write regression data
          writeData(wb, sheet = "Deming regression CI", demingcalci2)
          
          cat("\nDeming regression complete")
          output$deming <- renderPrint({
            do.call(rbind.data.frame,apply(demingcals, 2, function(x){
              cbind.data.frame(Mean= round(mean(x), 4),`SE`=round(sd(x)/sqrt(length(x)),7))
            }))
          })
          
        }
        
        #     checkboxInput("linear", "Linear model", FALSE),
        if(input$simulateBLM_measuredMaterial != FALSE) {
          sink(file = "out/Bayeslinmodtext.txt", type = "output")
          bayeslincals <<- simulateBLM_measuredMaterial(calData, 
                                                        replicates = replicates, 
                                                        isMixed=FALSE, 
                                                        generations=ngenerationsBayes,
                                                        priors = priors, 
                                                        samples = samples,
                                                        multicore = multicore)
          sink()
          incProgress(1/TotProgress, detail="...Done fitting the Bayesian linear regression model...")
          
          bayeslincinoerror <- RegressionSingleCI(data = bayeslincals$BLM_Measured_no_errors, from = minLim, to = maxLim)
          bayeslincalcinoerror <- as.data.frame(bayeslincinoerror)
          bayeslinciwitherror <- RegressionSingleCI(data = bayeslincals$BLM_Measured_errors, from = minLim, to = maxLim)
          bayeslincalciwitherror <- as.data.frame(bayeslinciwitherror)
          
          output$bayeslincalibration <- renderPlotly({
            bayeslinfig <- plot_ly(data = calibrationData()
            )
            bayeslinfig <- bayeslinfig %>% 
              add_trace(x = ~calibrationData()$Temperature, 
                        y = ~D47,
                        type = "scatter", 
                        mode = "markers", 
                        marker = list(color = "black"),
                        opacity = 0.5,
                        name = "Raw data",
                        text = as.character(calibrationData()$Sample.Name),
                        hovertemplate = paste(
                          "<b>Sample: %{text}</b><br><br>",
                          "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                          "Δ<sub>47</sub> (‰): %{y}<br>",
                          "Mineralogy: ", as.character(calibrationData()$Mineralogy),"<br>",
                          "Type: ", as.character(calibrationData()$Material),
                          "<extra></extra>")) %>%
              add_ribbons(data = bayeslincalcinoerror,
                          x = ~x,
                          y = ~mean_est,
                          ymin = ~ci_lower_est,
                          ymax = ~ci_upper_est,
                          line = list(color = "#ffd166"),
                          fillcolor = "#ffd166",
                          opacity = 0.5,
                          name = "95% CI - no error",
                          hovertemplate = paste(
                            "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                            "Δ<sub>47</sub> (‰): %{y}<br>")) %>%
              add_lines(data = bayeslincalcinoerror,
                        x = ~x,
                        y = ~mean_est,
                        name = "Mean estimate - no error",
                        line = list(color = "black", dash = "dash"),
                        hovertemplate = paste(
                          "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                          "Δ<sub>47</sub> (‰): %{y}<br>")) %>%
              add_ribbons(data = bayeslincalciwitherror,
                          x = ~x,
                          y = ~mean_est,
                          ymin = ~ci_lower_est,
                          ymax = ~ci_upper_est,
                          line = list(color = "#446455"),
                          fillcolor = "#446455",
                          opacity = 0.5,
                          name = "95% CI - with error",
                          hovertemplate = paste(
                            "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                            "Δ<sub>47</sub> (‰): %{y}<br>")) %>%
              add_lines(data = bayeslincalciwitherror,
                        x = ~x,
                        y = ~mean_est,
                        name = "Mean estimate - with error",
                        line = list(color = "#446455", dash = "dash"),
                        hovertemplate = paste(
                          "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                          "Δ<sub>47</sub> (‰): %{y}<br>"))
            bayeslinfig <- bayeslinfig %>% layout(title = "<b> Bayesian linear calibration model </b>",
                                                  legend=list(title=list(text="Legend")),
                                                  xaxis = list(title = "Temperature (10<sup>6</sup>/T<sup>2</sup>)", hoverformat = ".1f"), 
                                                  yaxis = list(title = "Δ<sub>47</sub> (‰)", hoverformat = ".3f"))
            
            return(bayeslinfig)
          })
          
          addWorksheet(wb, "Bayesian model no errors") # Add a blank sheet
          addWorksheet(wb, "Bayesian model no errors CI") # Add a blank sheet 
          addWorksheet(wb, "Bayesian model with errors") # Add a blank sheet
          addWorksheet(wb, "Bayesian model with errors CI") # Add a blank sheet 
          
          bayeslincalcinoerror2 <- bayeslincalcinoerror
          names(bayeslincalcinoerror2) <- c("10^6/T^2", "D47_mean_est",	"D47_ci_lower_est",	"D47_ci_upper_est")
          
          bayeslincalciwitherror2 <- bayeslincalciwitherror
          names(bayeslincalciwitherror2) <- c("10^6/T^2", "D47_mean_est",	"D47_ci_lower_est",	"D47_ci_upper_est")
          

          writeData(wb, sheet = "Bayesian model no errors", bayeslincals$BLM_Measured_no_errors) # Write regression data
          writeData(wb, sheet = "Bayesian model no errors CI", bayeslincalcinoerror2)
          
          writeData(wb, sheet = "Bayesian model with errors", bayeslincals$BLM_Measured_errors) # Write regression data
          writeData(wb, sheet = "Bayesian model with errors CI", bayeslincalciwitherror2)
          
          
          ##For the Bayesian sheet
          conv_BLM <- do.call(rbind, lapply(seq_along(attr(bayeslincals, "Conv")), function(x){
            cbind(Replicate=x,attr(bayeslincals, "Conv")[[x]][[1]]) }))
          conv_BLM_errors <- do.call(rbind, lapply(seq_along(attr(bayeslincals, "Conv")), function(x){
            cbind(Replicate=x,attr(bayeslincals, "Conv")[[x]][[2]]) }))
          
          conv_BLM <- cbind.data.frame(parameter=row.names(conv_BLM),conv_BLM)
          conv_BLM_errors <- cbind.data.frame(parameter=row.names(conv_BLM_errors),conv_BLM_errors)
          
          
          addWorksheet(wb3, "Bayesian model no errors") # Add a blank sheet
          addWorksheet(wb3, "Bayesian model with errors") # Add a blank sheet
          writeData(wb3, sheet = "Bayesian model no errors", conv_BLM) # Write regression data
          writeData(wb3, sheet = "Bayesian model with errors", conv_BLM_errors) # Write regression data
          
          ##For the posterior sheet
          
          addWorksheet(wb4, "Bayesian model no errors") # Add a blank sheet
          addWorksheet(wb4, "Bayesian model with errors") # Add a blank sheet
          writeData(wb4, sheet = "Bayesian model no errors", attr(bayeslincals, "PosteriorOne")[[2]]) # Write regression data
          writeData(wb4, sheet = "Bayesian model with errors", attr(bayeslincals, "PosteriorOne")[[1]]) # Write regression data
          
          #print(noquote("Bayesian linear model complete"))
          
          cat( paste0("\nBayesian linear model complete \n *with errors \n   *R^2=", round(attr(bayeslincals,"R2s")[1,2],4),
                               " (95% CI, ",round(attr(bayeslincals,"R2s")[1,3],4),"-",round(attr(bayeslincals,"R2s")[1,4],4),")",
                      "\n   *DIC=", round(attr(bayeslincals,"DICs")[1,1],4),
                      " (95% CI, ",round(attr(bayeslincals,"DICs")[1,2],4),"-",round(attr(bayeslincals,"DICs")[1,2],4),")",
                      "\n *without errors\n   *R^2=", round(attr(bayeslincals,"R2s")[2,2],4),
                               " (95% CI, ",round(attr(bayeslincals,"R2s")[2,3],4),"-",round(attr(bayeslincals,"R2s")[2,4],4),")",
                      "\n   *DIC=", round(attr(bayeslincals,"DICs")[2,1],4),
                      " (95% CI, ",round(attr(bayeslincals,"DICs")[2,2],4),"-",round(attr(bayeslincals,"DICs")[2,2],4),")"
          )
          )
          
          output$blinnoerr <- renderPrint({
            
            do.call(rbind.data.frame,apply(bayeslincals$BLM_Measured_no_errors, 2, function(x){
              cbind.data.frame(Mean= round(mean(x), 4),`SE`=round(sd(x)/sqrt(length(x)),7))
            }))
            
          })
          
          output$blinwerr <- renderPrint({
            
            do.call(rbind.data.frame,apply(bayeslincals$BLM_Measured_errors, 2, function(x){
              cbind.data.frame(Mean=round(mean(x), 4),`SE`=round(sd(x)/sqrt(length(x)),7))
            }))
            
          })
          
        }
        
        if(length(unique(calData$Material)) < 2 & input$simulateBLMM_measuredMaterial != FALSE) {
          print(noquote("Bayesian linear mixed models require multiple materials"))
        }
        
        if(input$simulateBLMM_measuredMaterial != FALSE) { #length(unique(calData$Material)) >= 2 &
          calData$MaterialName <<- calData$Material
          calData$Material <<- as.factor(as.numeric(as.factor(calData$Material)))
          sink(file = "out/Bayesmixmodtext.txt", type = "output")
          bayesmixedcals <<- simulateBLM_measuredMaterial(data=calData, 
                                                         replicates = replicates, 
                                                         isMixed = T, 
                                                         generations=ngenerationsBayes,
                                                         priors = priors, 
                                                         samples = samples,
                                                         multicore = multicore)
          sink()
          incProgress(1/TotProgress, detail="...Done fitting the Bayesian linear mixed regression model...")
          
          bayeslmminciwitherror <- RegressionSingleCI(data = bayesmixedcals$BLMM_Measured_errors, from = minLim, to = maxLim)
          bayeslmmincalciwitherror <- as.data.frame(bayeslmminciwitherror)

          addWorksheet(wb, "Bayesian mixed w errors") # Add a blank sheet
          addWorksheet(wb, "Bayesian mixed w errors CI") # Add a blank sheet 
          
          bayeslmmincalciwitherror2 <- bayeslmmincalciwitherror
          names(bayeslmmincalciwitherror2) <- c("10^6/T^2", "D47_mean_est",	"D47_ci_lower_est",	"D47_ci_upper_est")
          
          writeData(wb, sheet = "Bayesian mixed w errors", bayesmixedcals$BLMM_Measured_errors) # Write regression data
          writeData(wb, sheet = "Bayesian mixed w errors CI", bayeslmmincalciwitherror2)
          
          ##For the Bayesian sheet
          conv_BLMM <- do.call(rbind, lapply(seq_along(attr(bayesmixedcals, "Conv")), function(x){
            cbind(Replicate=x,attr(bayesmixedcals, "Conv")[[x]][[1]]) }))

          conv_BLMM <- cbind.data.frame(parameter=row.names(conv_BLMM),conv_BLMM)
          
          addWorksheet(wb3, "Bayesian mixed w errors") # Add a blank sheet
          writeData(wb3, sheet = "Bayesian mixed w errors", conv_BLMM) # Write regression data
          
          addWorksheet(wb4, "Bayesian mixed w errors") # Add a blank sheet
          writeData(wb4, sheet = "Bayesian mixed w errors", attr(bayesmixedcals, "PosteriorOne")) # Write regression data
          
          output$bayesmixedcalibration <- renderPlotly({
            bayesmixedfig <- plot_ly(data = calibrationData()
            )
            bayesmixedfig <- bayesmixedfig %>% 
              add_trace(x = ~calibrationData()$Temperature, 
                        y = ~D47,
                        type = "scatter", 
                        mode = "markers", 
                        marker = list(color = "black"),
                        opacity = 0.5,
                        name = "Raw data",
                        text = as.character(calibrationData()$Sample.Name),
                        hovertemplate = paste(
                          "<b>Sample: %{text}</b><br><br>",
                          "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                          "Δ<sub>47</sub> (‰): %{y}<br>",
                          "Mineralogy: ", as.character(calibrationData()$Mineralogy),"<br>",
                          "Type: ", as.character(calibrationData()$Material),
                          "<extra></extra>")) %>%
              add_ribbons(data = bayeslmmincalciwitherror,
                          x = ~x,
                          y = ~mean_est,
                          ymin = ~ci_lower_est,
                          ymax = ~ci_upper_est,
                          line = list(color = "#446455"),
                          fillcolor = "#446455",
                          opacity = 0.5,
                          name = "95% CI - with error",
                          hovertemplate = paste(
                            "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                            "Δ<sub>47</sub> (‰): %{y}<br>")) %>%
              add_lines(data = bayeslmmincalciwitherror,
                        x = ~x,
                        y = ~mean_est,
                        name = "Mean estimate - with error",
                        line = list(color = "#446455", dash = "dash"),
                        hovertemplate = paste(
                          "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                          "Δ<sub>47</sub> (‰): %{y}<br>"))
            bayesmixedfig <- bayesmixedfig %>% layout(title = "<b> Bayesian mixed model </b>",
                                                  legend=list(title=list(text="Legend")),
                                                  xaxis = list(title = "Temperature (10<sup>6</sup>/T<sup>2</sup>)", hoverformat = ".1f"), 
                                                  yaxis = list(title = "Δ<sub>47</sub> (‰)", hoverformat = ".3f"))
            
            return(bayesmixedfig)
          })
          
          
          cat( paste0("\nBayesian mixed model complete \n *R^2 (conditional)=", round(attr(bayesmixedcals,"R2s")[3,3],4),
                      " (95% CI, ",round(attr(bayesmixedcals,"R2s")[3,4],4),"-",round(attr(bayesmixedcals,"R2s")[3,5],4),")",
                      "\n *R^2 (marginal)=", round(attr(bayesmixedcals,"R2s")[4,3],4),
                      " (95% CI, ",round(attr(bayesmixedcals,"R2s")[4,4],4),"-",round(attr(bayesmixedcals,"R2s")[4,5],4),")",
                      "\n *DIC=", round(attr(bayesmixedcals,"DIC")[3,1],4),
                      " (95% CI, ",round(attr(bayesmixedcals,"DIC")[3,2],4),"-",round(attr(bayesmixedcals,"DIC")[3,3],4),")"
          )
          )
          
          output$blinmwerr <- renderPrint(
            ddply(bayesmixedcals$BLMM_Measured_errors, .( material), 
                  function(x) cbind.data.frame("Mean (Intercept)"=round(mean(x$intercept),4),
                                               "SE (Intercept)"=round(sd(x$slope)/sqrt(length(x$intercept)),7),
                            
                            "Mean (Slope)"=round(mean(x$slope),4),
                            "SE (Slope)"=round(sd(x$slope)/sqrt(length(x$slope)),7))
            )
        ) 

      
        }
        
      })
      
    }
    
  })
  
  output$modresults <- renderPrint({
    modresult()
  })
  
  output$downloadcalibrations <- downloadHandler(
    filename = function() { 
      paste("Calibration_output_", Sys.time(), ".xlsx", sep="")
    },
    
    content = function(file) {
      saveWorkbook(wb, file, overwrite = TRUE)
    }
  )
  
  
  output$downloadBayesian <- downloadHandler(
    filename = function() { 
      paste("Bayesian_output_", Sys.time(), ".xlsx", sep="")
    },
    
    content = function(file) {
      saveWorkbook(wb3, file, overwrite = TRUE)
    }
  )
  
  output$downloadPosteriorCalibration <- downloadHandler(
    filename = function() { 
      paste("Bayesian_posterior_output_", Sys.time(), ".xlsx", sep="")
    },
    
    content = function(file) {
      saveWorkbook(wb4, file, overwrite = TRUE)
    }
  )
  
  
  ########################### Example code
  #    output$calstorun<-renderText({
  #      return(caltorun)
  #})
  ###################################################
  
  
  # Calibration plots tab
  
  observe({
    minlength <- length(unique(calibrationData()$Mineralogy))
    if( !all(is.na(calibrationData()$Mineralogy)) == TRUE ){
    output$rawcaldata <- renderPlotly({
      rawcalfig <- plot_ly(calibrationData(), 
                           x = ~Temperature, 
                           y = ~D47, 
                           type = "scatter", 
                           mode = "lines+markers", 
                           linetype = ~as.factor(Material), 
                           color = ~as.factor(Mineralogy),
                           colors = viridis_pal(option = "D", end = 0.9)(minlength),
                           opacity = 0.6,
                           error_y = ~list(array = ~D47error, color = "#000000"),
                           error_x = ~list(array = ~TempError, color = "#000000"),
                           text = as.character(calibrationData()$Sample.Name),
                           hovertemplate = paste(
                             "<b>Sample: %{text}</b><br><br>",
                             "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                             "Δ<sub>47</sub> (‰): %{y}<br>",
                             "Mineralogy: ", as.character(calibrationData()$Mineralogy),"<br>",
                             "Type: ", as.character(calibrationData()$Material),
                             "<extra></extra>"))
      rawcalfig <- rawcalfig %>% layout(title = "<b> Raw calibration data from user input </b>",
                                        legend=list(title=list(text="Material and mineralogy")),
                                        xaxis = list(title = "Temperature (10<sup>6</sup>/T<sup>2</sup>)"), 
                                        yaxis = list(title = "Δ<sub>47</sub> (‰)", hoverformat = ".3f"))
      
      return(rawcalfig)
    })
    }else{
      output$rawcaldata <- renderPlotly({
        rawcalfig <- plot_ly(calibrationData(), 
                             x = ~Temperature, 
                             y = ~D47, 
                             type = "scatter", 
                             mode = "lines+markers", 
                             linetype = ~as.factor(Material), 
                             color = ~as.factor(Material),
                             colors = viridis_pal(option = "D", end = 0.9)(length(unique(calibrationData()$Material))),
                             opacity = 0.6,
                             error_y = ~list(array = ~D47error, color = "#000000"),
                             error_x = ~list(array = ~TempError, color = "#000000"),
                             text = as.character(calibrationData()$Sample.Name),
                             hovertemplate = paste(
                               "<b>Sample: %{text}</b><br><br>",
                               "Temperature (10<sup>6</sup>/T<sup>2</sup>): %{x}<br>",
                               "Δ<sub>47</sub> (‰): %{y}<br>",
                               "Type: ", as.character(calibrationData()$Material),
                               "<extra></extra>"))
        rawcalfig <- rawcalfig %>% layout(title = "<b> Raw calibration data from user input </b>",
                                          legend=list(title=list(text="Material")),
                                          xaxis = list(title = "Temperature (10<sup>6</sup>/T<sup>2</sup>)"), 
                                          yaxis = list(title = "Δ<sub>47</sub> (‰)", hoverformat = ".3f"))
        
        return(rawcalfig)
      })
    }
  })
  
  # Reconstruction tab
  
  output$BayClump_reconstruction_template.csv <- downloadHandler(
    filename = "BayClump_reconstruction_template.csv",
    content = function(file) {
      write.csv(BayClump_reconstruction_template, file, row.names = FALSE)
    }
  )

  reconstructionData = reactive({
    req(input$reconstructiondata)
    n_rows = length(count.fields(input$reconstructiondata$datapath))
    df_out = read.csv(input$reconstructiondata$datapath)
    return(df_out)
  })
  
  if(exists("wb2")) rm(wb2) # Delete any existing workbook in preparation for new results
  wb2 <- createWorkbook("reconstruction output") # Prepare a workbook for reconstruction outputs
  
  observe({
    output$contents2 <- renderTable({
      recsummary <- reconstructionData() %>%
        summarize(
          "Unique samples" = length(unique(reconstructionData()$Sample)),
          "Total replicates" = sum(reconstructionData()$N),
          "Materials" = length(unique(reconstructionData()$Material))
        )
      return(recsummary)
    }, 
    rownames=FALSE, options = list(pageLength = 1, info = FALSE)
    )
  })
  
  recresult <- eventReactive(input$runrec, {
    
    if(is.null(input$reconstructiondata)) {print(noquote("Please upload reconstruction data first"))}
    if(!is.null(input$reconstructiondata)) {
      
      recData <- NULL
      recData <- reconstructionData()
      
      hasMaterial <- ifelse( is.na(reconstructionData()$Material), FALSE, TRUE )
      
      # Remove existing worksheets from wb2 on "run" click, if any
      if("Linear" %in% names(wb2) == TRUE) 
      {removeWorksheet(wb2, "Linear")}
      if("Linear w no uncertainty" %in% names(wb2) == TRUE) 
      {removeWorksheet(wb2, "Linear w no uncertainty")}
      
      
      if("Inverse linear" %in% names(wb2) == TRUE) 
      {removeWorksheet(wb2, "Inverse linear")}
      if("Inverse linear w no uncertainty" %in% names(wb2) == TRUE) 
      {removeWorksheet(wb2, "Inverse linear w no uncertainty")}
      
      if("York" %in% names(wb2) == TRUE) 
      {removeWorksheet(wb2, "York")}
      if("York w no uncertainty" %in% names(wb2) == TRUE) 
      {removeWorksheet(wb2, "York w no uncertainty")}
      
      if("Deming" %in% names(wb2) == TRUE) 
      {removeWorksheet(wb2, "Deming")}
      if("Deming w no uncertainty" %in% names(wb2) == TRUE) 
      {removeWorksheet(wb2, "Deming w no uncertainty")}
      
      if("Bayes and error" %in% names(wb2) == TRUE) 
      {removeWorksheet(wb2, "Bayes and error") }
      if("Bayes w error no uncertainty" %in% names(wb2) == TRUE) 
      {removeWorksheet(wb2, "Bayes w error no uncertainty") }
      
      if("Bayesian predictions" %in% names(wb2) == TRUE) 
      {removeWorksheet(wb2, "Bayesian predictions")}
      if("Bayesian mixed model" %in% names(wb2) == TRUE)
      {removeWorksheet(wb2, "Bayesian mixed model")}
      if("Bayesian linear model, errors" %in% names(wb2) == TRUE)
      {removeWorksheet(wb2, "Bayesian linear model, errors")}
      if("Bayesian linear model" %in% names(wb2) == TRUE)
      {removeWorksheet(wb2, "Bayesian linear model")}
      if("Bayesian linear mixed model" %in% names(wb2) == TRUE)
      {removeWorksheet(wb2, "Bayesian linear mixed model")}
      
      
      ##Also for the Bayesian posterior sheet
      if("Bayesian model no errors" %in% names(wb5) == TRUE) 
      {removeWorksheet(wb5, "Bayesian model no errors")}
      if("Bayesian model with errors" %in% names(wb5) == TRUE) 
      {removeWorksheet(wb5, "Bayesian model with errors") }
      if("Bayesian mixed w errors" %in% names(wb5) == TRUE)
      {removeWorksheet(wb5, "Bayesian mixed w errors")}
      
      if(input$confirm == FALSE) { print(noquote("Please confirm that your reference frames match")) }
      if(input$confirm == TRUE) {
        
        
        totalModelsRecs <- c(input$simulateLM_measuredRec, input$simulateLM_inverseweightsRec, input$simulateYork_measuredRec,
                         input$simulateDemingRec, input$simulateBLM_measuredMaterialRec, input$simulateBLMM_measuredMaterialRec)
        totalModelsRecs <- length(which(totalModelsRecs==T))
        
        
        withProgress(message = "Running selected reconstructions, please wait", {
          
          # Misc options
          
          AccountErrorDataset <- input$AccountErrorDataset
          
          if(input$simulateBLM_measuredMaterialRec == TRUE){
            
            if(is.null(bayeslincals)) { print(noquote("Please run the calibration step for Bayesian linear models first")) }else{
              
            ##This function runs only Bayesian predictions
            ##(Only Bayesian simple linear with error for now)
            sink("out/bayespredictions.txt", type = "output")
            
            ##Linear models
            infTempBayesianCLinear <- predictTcBayes(calibrationData=calData,
                                     data=cbind(recData$D47,
                                                ifelse(recData$D47error==0,0.00001,recData$D47error),
                                                as.numeric(as.factor(ifelse(is.na(recData$Material), 1,recData$Material))),
                                                nobs=recData$N),
                                     generations=ngenerationsBayes,
                                     hasMaterial=F, bootDataset=T, onlyMedian=T, replicates = replicates, multicore = multicore, priors=priors,
                                     errorsD47=AccountErrorDataset)
            
          sink()
          incProgress(1/totalModelsRecs, detail="...Done fitting the Bayesian linear models...")
          
          infTempBayesian_werrors<- infTempBayesianCLinear[infTempBayesianCLinear[,1]=="BLM1_fit",]

          df0<-infTempBayesian_werrors[,-c(1,4)]
          names(df0) <- c("Δ47 (‰)", "Δ47 (‰) error", "Temperature (°C)", "1SD Temperature (°C)")
          rownames(df0) <- NULL
          
          output$BpredictionsErrors <- renderTable({
            
            df0$`Δ47 (‰)` <- formatC(df0$`Δ47 (‰)`, digits = 3, format = "f")
            df0$`Δ47 (‰) error` <- formatC(df0$`Δ47 (‰) error`, digits = 4, format = "f")
            df0$`Temperature (°C)` <- formatC(df0$`Temperature (°C)`, digits = 1, format = "f")
            df0$`1SD Temperature (°C)` <- formatC(df0$`1SD Temperature (°C)`, digits = 7, format = "f")
            head(df0)
          },
            caption = "Bayesian predictions (BLM_errors)",
            caption.placement = getOption("xtable.caption.placement", "top"),
          rownames = FALSE,
          spacing = "m",
          align = "c"
            
          )
          
          addWorksheet(wb2, "Bayesian linear model, errors") # Add a blank sheet
          writeData(wb2, sheet = "Bayesian linear model, errors", df0)
          
          ##Without errors
          infTempBayesian<-infTempBayesianCLinear[infTempBayesianCLinear[,1]=="BLM1_fit_NoErrors",]
          df0.1<-infTempBayesian[,-c(1,4)]
          names(df0.1) <- c("Δ47 (‰)", "Δ47 (‰) error", "Temperature (°C)", "1SD Temperature (°C)")
          rownames(df0.1) <- NULL
          
          output$Bpredictions <- renderTable({
            
            df0.1$`Δ47 (‰)` <- formatC(df0.1$`Δ47 (‰)`, digits = 3, format = "f")
            df0.1$`Δ47 (‰) error` <- formatC(df0.1$`Δ47 (‰) error`, digits = 4, format = "f")
            df0.1$`Temperature (°C)` <- formatC(df0.1$`Temperature (°C)`, digits = 1, format = "f")
            df0.1$`1SD Temperature (°C)` <- formatC(df0.1$`1SD Temperature (°C)`, digits = 7, format = "f")
            head(df0.1)
          },
            caption = "Bayesian predictions (BLM without errors)",
            caption.placement = getOption("xtable.caption.placement", "top"),
          rownames = FALSE,
          spacing = "m",
          align = "c"
            
          )
          
          addWorksheet(wb2, "Bayesian linear model") # Add a blank sheet
          writeData(wb2, sheet = "Bayesian linear model", df0.1)
          print(noquote("Bayesian linear models complete"))
          
          
          attr(infTempBayesianCLinear, "PosteriorOne")[[2]]
          
          addWorksheet(wb5, "Bayesian model no errors") # Add a blank sheet
          addWorksheet(wb5, "Bayesian model with errors") # Add a blank sheet
          writeData(wb5, sheet = "Bayesian model no errors", attr(infTempBayesianCLinear, "PosteriorOne")[[2]]) # Write regression data
          writeData(wb5, sheet = "Bayesian model with errors", attr(infTempBayesianCLinear, "PosteriorOne")[[1]]) # Write regression data
          

          }
          }
          

          
          if(input$simulateBLMM_measuredMaterialRec == TRUE){
            if(is.null(bayesmixedcals)) { print(noquote("Please run the calibration step for Bayesian linear models first")) }else{
            
            
             
            ## Mixed model
              sink("out/bayespredictionsMixed.txt", type = "output")
              
              infTempBayesianCMixed <-predictTcBayes(calibrationData=calData,
                                        data=cbind(recData$D47,
                                                   ifelse(recData$D47error==0,0.00001,recData$D47error),
                                                   as.numeric(as.factor(ifelse(is.na(recData$Material), 1,recData$Material))),
                                                   nobs=recData$N),
                                        generations=ngenerationsBayes,
                                        hasMaterial=T, bootDataset=T, onlyMedian=T, replicates = replicates, multicore = multicore, priors=priors,
                                        errorsD47=AccountErrorDataset)
              sink()
              incProgress(1/totalModelsRecs, detail="...Done fitting the Bayesian linear mixed models...")
              
              df0.2<-infTempBayesianCMixed[,-1]
              names(df0.2) <- c("Δ47 (‰)", "Δ47 (‰) error","Material", "Temperature (°C)", "1SD Temperature (°C)")
              rownames(df0.2) <- NULL
              
              output$BpredictionsBLMM <- renderTable({
                
                df0.2$`Δ47 (‰)` <- formatC(df0.2$`Δ47 (‰)`, digits = 3, format = "f")
                df0.2$`Δ47 (‰) error` <- formatC(df0.2$`Δ47 (‰) error`, digits = 4, format = "f")
                df0.2$`Temperature (°C)` <- formatC(df0.2$`Temperature (°C)`, digits = 1, format = "f")
                df0.2$`1SD Temperature (°C)` <- formatC(df0.2$`1SD Temperature (°C)`, digits = 7, format = "f")
                head(df0.2)
              },
              caption = "Bayesian predictions under a Bayesian linear mixed model",
              caption.placement = getOption("xtable.caption.placement", "top"),
              rownames = FALSE,
              spacing = "m",
              align = "c"
              )
              
              addWorksheet(wb2, "Bayesian linear mixed model") # Add a blank sheet
              writeData(wb2, sheet = "Bayesian linear mixed model", df0.2)
              
              addWorksheet(wb5, "Bayesian linear mixed model") # Add a blank sheet
              writeData(wb5, sheet = "Bayesian linear mixed model", attr(infTempBayesianCMixed, "PosteriorOne")) # Write regression data
              
              print(noquote("Bayesian linear mixed model complete"))
              
          
            }
              }
          
          
          if( input$simulateLM_measuredRec == TRUE ) {
            
            if(is.null(lmcals)) { print(noquote("Please run the calibration step for linear models first")) }else{
              
              sink("out/LMpredictions.txt", type = "output")
              
            calData$T2 <<- calData$Temperature

            lmrec <<-  do.call(rbind,lapply(1:nrow(recData), function(x){
                a <- predictTc(calData, targety=recData$D47[x], model="lm", replicates=replicates, bootDataset=AccountErrorDataset)
                b <- predictTc(calData, targety=recData$D47[x]+recData$D47error[x], model="lm", replicates=replicates, bootDataset=AccountErrorDataset)
                cbind.data.frame("D47"=recData$D47[x],"D47se"=recData$D47error[x], "Tc"=a$temp, "se"=a$temp-b$temp)
              } ))
            sink()
            df1 <- lmrec
            
            
            names(df1) <- c("Δ47 (‰)", "Δ47 (‰) error", "Temperature (°C)", "1SD Temperature (°C)")
            rownames(df1) <- NULL
            
           
            output$lmrecswun <- renderTable({
              
              df1$`Δ47 (‰)` <- formatC(df1$`Δ47 (‰)`, digits = 3, format = "f")
              df1$`Δ47 (‰) error` <- formatC(df1$`Δ47 (‰) error`, digits = 4, format = "f")
              df1$`Temperature (°C)` <- formatC(df1$`Temperature (°C)`, digits = 1, format = "f")
              df1$`1SD Temperature (°C)` <- formatC(df1$`1SD Temperature (°C)`, digits = 7, format = "f")
              head(df1)
            },
              caption = "Linear model",
              caption.placement = getOption("xtable.caption.placement", "top"),
              rownames = FALSE,
              spacing = "m",
              align = "c"
            )
            
            addWorksheet(wb2, "Linear") # Add a blank sheet
            writeData(wb2, sheet = "Linear", df1) # Write reconstruction data
            print(noquote("Linear reconstruction complete"))
            
          
            }
            }
          
          
          #Inverse weighted linear model 
          if( input$simulateLM_inverseweightsRec == TRUE ) {
            if(is.null(lminversecals)) { print(noquote("Please run the calibration step for weighted OLS models first")) }else{
              
            sink("out/wLMpredictions.txt", type = "output")
              
            calData$T2 <<- calData$Temperature
            
            lminverserec <<-  do.call(rbind,lapply(1:nrow(recData), function(x){
                a <- predictTc(calData, targety=recData$D47[x], model="wlm", replicates=replicates, bootDataset=AccountErrorDataset)
                b <- predictTc(calData, targety=recData$D47[x]+recData$D47error[x], model="wlm", replicates=replicates, bootDataset=AccountErrorDataset)
                cbind.data.frame("D47"=recData$D47[x],"D47se"=recData$D47error[x], "Tc"=a$temp, "se"=a$temp-b$temp)
                } ))
              sink()
            incProgress(1/totalModelsRecs, detail="...Done fitting the weighted OLS...")
            
            
              colnames(lminverserec)[3] <- "Tc"
              lminverserec$D47se <- recData$D47error
              lminverserec[,c("D47","D47se", "Tc", "se")]
            
              
            lminverserecwun <- lminverserec
            df3<-lminverserecwun
            
            names(df3) <- c("Δ47 (‰)", "Δ47 (‰) error", "Temperature (°C)", "1SD Temperature (°C)")
            rownames(df3) <- NULL
            
            
            
            output$lminverserecswun <- renderTable({
              
              df3$`Δ47 (‰)` <- formatC(df3$`Δ47 (‰)`, digits = 3, format = "f")
              df3$`Δ47 (‰) error` <- formatC(df3$`Δ47 (‰) error`, digits = 4, format = "f")
              df3$`Temperature (°C)` <- formatC(df3$`Temperature (°C)`, digits = 1, format = "f")
              df3$`1SD Temperature (°C)` <- formatC(df3$`1SD Temperature (°C)`, digits = 7, format = "f")
              head(df3)
            },
              caption = "Inverse weighted linear model",
              caption.placement = getOption("xtable.caption.placement", "top"),
            rownames = FALSE,
            spacing = "m",
            align = "c"
              
            )
            
            addWorksheet(wb2, "Inverse linear") # Add a blank sheet
            writeData(wb2, sheet = "Inverse linear", df3) # Write reconstruction data
            print(noquote("Inverse weighted linear reconstruction complete"))
            
            
          
            }
            }
          
          # York regression
          if( input$simulateYork_measuredRec == TRUE ) {
            if(is.null(yorkcals)) { print(noquote("Please run the calibration step for York models first")) }else{
              
              sink("out/Yorkpredictions.txt", type = "output")
              
            calData$T2 <<- calData$Temperature

            yorkrec <<-   do.call(rbind,lapply(1:nrow(recData), function(x){
                a <- predictTc(calData, targety=recData$D47[x], model="York", replicates=replicates, bootDataset=AccountErrorDataset)
                b <- predictTc(calData, targety=recData$D47[x]+recData$D47error[x], model="York", replicates=replicates, bootDataset=AccountErrorDataset)
                cbind.data.frame("D47"=recData$D47[x],"D47se"=recData$D47error[x], "Tc"=a$temp, "se"=a$temp-b$temp)
              } ))
              sink()
            incProgress(1/totalModelsRecs, detail="...Done fitting the York regression...")
            
            
              colnames(yorkrec)[3] <- "Tc"
              yorkrec$D47se <- recData$D47error
              yorkrec[,c("D47","D47se", "Tc", "se")]
            
            
            df5 <- yorkrec
            names(df5) <- c("Δ47 (‰)", "Δ47 (‰) error", "Temperature (°C)", "1SD Temperature (°C)")
            rownames(df5) <- NULL
            
            
            output$yorkrecswun <- renderTable({
              
              df5$`Δ47 (‰)` <- formatC(df5$`Δ47 (‰)`, digits = 3, format = "f")
              df5$`Δ47 (‰) error` <- formatC(df5$`Δ47 (‰) error`, digits = 4, format = "f")
              df5$`Temperature (°C)` <- formatC(df5$`Temperature (°C)`, digits = 1, format = "f")
              df5$`1SD Temperature (°C)` <- formatC(df5$`1SD Temperature (°C)`, digits = 7, format = "f")
              head(df5)
            },
              caption = "York regression",
              caption.placement = getOption("xtable.caption.placement", "top"),
            rownames = FALSE,
            spacing = "m",
            align = "c"
              
            )
            
            addWorksheet(wb2, "York") # Add a blank sheet
            writeData(wb2, sheet = "York", df5) # Write reconstruction data
            print(noquote("York reconstruction complete"))

          
            }
            }
          
          # Deming regression
          if( input$simulateDemingRec == TRUE ) {
            if(is.null(demingcals) ) { print(noquote("Please run the calibration step for Deming models first")) }else{
              
              sink("out/Demingpredictions.txt", type = "output")
              
            calData$T2 <<- calData$Temperature

            demingrec <<- do.call(rbind,lapply(1:nrow(recData), function(x){
                a <- predictTc(calData, targety=recData$D47[x], model="Deming", replicates=replicates, bootDataset=AccountErrorDataset)
                b <- predictTc(calData, targety=recData$D47[x]+recData$D47error[x], model="Deming", replicates=replicates, bootDataset=AccountErrorDataset)
                cbind.data.frame("D47"=recData$D47[x],"D47se"=recData$D47error[x], "Tc"=a$temp, "se"=a$temp-b$temp)
                
                } ))
            sink()
            incProgress(1/totalModelsRecs, detail="...Done fitting the Deming regression...")
            
            
              colnames(demingrec)[3] <- "Tc"
              demingrec$D47se <- recData$D47error
              demingrec[,c("D47","D47se", "Tc", "se")]
            

            df7 <- demingrec
            names(df7) <- c("Δ47 (‰)", "Δ47 (‰) error", "Temperature (°C)", "1SD Temperature (°C)")
            rownames(df7) <- NULL

            output$demingrecswun <- renderTable({
              
              df7$`Δ47 (‰)` <- formatC(df7$`Δ47 (‰)`, digits = 3, format = "f")
              df7$`Δ47 (‰) error` <- formatC(df7$`Δ47 (‰) error`, digits = 4, format = "f")
              df7$`Temperature (°C)` <- formatC(df7$`Temperature (°C)`, digits = 1, format = "f")
              df7$`1SD Temperature (°C)` <- formatC(df7$`1SD Temperature (°C)`, digits = 7, format = "f")
              head(df7)
            },
              caption = "Deming regression",
              caption.placement = getOption("xtable.caption.placement", "top"),
            rownames = FALSE,
            spacing = "m",
            align = "c"
              
            )
            
            
            addWorksheet(wb2, "Deming") # Add a blank sheet
            writeData(wb2, sheet = "Deming", df7) # Write reconstruction data
            print(noquote("Deming reconstruction complete"))
            
            
          
            }
            }

        })
      } 
    }
  })
  
  
  output$recresults <- renderPrint({
    recresult()
  })
  
  output$downloadreconstructions <- downloadHandler(
    filename = function() { 
      paste("Reconstruction_output_", Sys.time(), ".xlsx", sep="")
    },
    
    content = function(file) {
      saveWorkbook(wb2, file, overwrite = TRUE)
    }
  )
  
  output$downloadreconstructionsPosterior <- downloadHandler(
    filename = function() { 
      paste("Reconstruction_posterior_output_", Sys.time(), ".xlsx", sep="")
    },
    
    content = function(file) {
      saveWorkbook(wb5, file, overwrite = TRUE)
    }
  )
  
}
  